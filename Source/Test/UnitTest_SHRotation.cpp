//uinit test for rigid transform class
#include "Noise3D.h"
#include <iostream>
#include <iomanip>

using namespace Noise3D;
const int c_bandWidth = 8;
GI::SHRotationWignerMatrix wm(c_bandWidth);

void OutputWignerMatrixByIndex()
{
	for (int L = 0; L <= c_bandWidth; ++L)
	{
		std::cout << "***Matrix Band" << L << "***" << std::endl;
		for (int m = -L; m <= L; ++m)
		{
			float squareSum = 0;
			for (int n = -L; n <= L; ++n)
			{
				float element = wm.GetByIndex(L, m, n);
				squareSum += element * element;
				std::cout << "(" << m << "," << n << "):" << element << "\t";
			}
			std::cout << "sqsum:"<<squareSum<< std::endl;
		}
		std::cout << std::endl;
	}
}

void OutputWignerMatrixByRowCol()
{
	for (int L = 0; L <= c_bandWidth; ++L)
	{
		std::cout << "***Matrix Band" << L << "***" << std::endl;
		for (int m = 0; m < 2 * L + 1; ++m)
		{
			for (int n = 0; n < 2 * L + 1; ++n)
			{
				std::cout << wm.GetByRowCol(L, m, n) << "  ";
			}
			std::cout << std::endl;
		}
		std::cout << std::endl;
	}
}

void UnitTest_WignerMatrixAccess()
{
	for (int L = 0; L <= c_bandWidth; ++L)
	{
		for (int row = 0; row < 2*L+1; ++row)
		{
			for (int col = 0; col < 2 * L + 1; ++col)
			{
				wm.SetByRowCol(L, row, col, row + 0.1f* col);
			}
		}
	}

	OutputWignerMatrixByRowCol();
	OutputWignerMatrixByIndex();
};

void UnitTest_WignerMatrixConstruction()
{
	RigidTransform t;
	t.SetRotation(Vec3(0.3f, 0.5f, 0.7f));
	//t.SetRotation(Vec3(0, 0, 0.7f));

	std::vector<NColor4f> shVector((c_bandWidth+1)*(c_bandWidth+1));
	auto rotatedShvector = shVector;
	float R[81] = { 1.89176f, 0.147793f, 0.0725107f, -1.3557f, 0.0668765f, -0.00159497f, 0.076401f, 0.00962941f, -0.0184065f, 0.0395602f, 0.00551895f, 0.0423098f, 0.050047f, -0.322272f, -0.0523142f, 0.415194f, -0.00628356f, -0.00315487f, 0.0251444f, 0.00324166f, 0.0297385f, 0.00327502f, -0.0262009f, -0.00737244f, 0.0296777f, 0.0634562f, -0.00303474f, -0.0324813f, -0.00323109f, 0.0119197f, 0.0376285f, -0.152116f, -0.00287243f, 0.163398f, 0.01722f, -0.198499f, 0.0147604f, 0.0115825f, 0.00341647f, 0.000823077f, 0.0043027f, -0.00340923f, -0.0154904f, 0.00732499f, -0.0083991f, -0.00192829f, 0.0337915f, 0.00706832f, -0.0634374f, -0.0590887f, -0.00924721f, 0.0294898f, 0.00442983f, -0.0289442f, 0.0159953f, -0.000372337f, -0.018561f, -0.0979477f, 0.00942579f, 0.0908754f, 0.0101473f, -0.121293f, -0.0122807f, 0.128831f, -0.0119695f, 0.0113642f, -0.00823904f, -0.00591753f, 0.00609065f, -0.0130698f, 0.00253708f, 0.0139286f, 0.0192703f, -0.00291646f, -0.0107584f, -0.00566373f, 0.0188755f, -0.0178383f, -0.0145432f, -2.10396e-5f, 0.0653154 };
	float G[81] = { 2.21898f, 0.691775f, -0.00563765f, 0.114006f, -0.534162f, 0.0241509f, 0.0679529f, 0.00501163f, 0.0969044f, 0.181f, 0.00688144f, 0.173394f, 0.00978072f, -0.0256997f, 0.00768402f, -0.15834f, 0.022793f, -0.0182594f, -0.171103f, 0.0217151f, 0.0497648f, -0.00248237f, 0.0700067f, 0.00973728f, 0.0786843f, 0.01491f, 0.00408154f, 0.00375832f, -0.00809798f, 0.00853961f, 0.126367f, -0.0701978f, 0.00416758f, -0.065882f, 0.0192708f, 0.0241142f, -0.00141772f, 0.0335802f, 0.0153575f, -0.0157156f, 0.00890569f, 0.00840553f, -0.0979016f, -0.126012f, -0.00467361f, 0.0181598f, 0.00433475f, -0.0990999f, -0.0250867f, -0.00892053f, 0.00052554f, -0.000720902f, 0.00140446f, -0.0140422f, 0.0111716f, 0.00121904f, -0.0596245f, 0.105039f, 0.00847291f, 0.00599203f, 0.00861912f, 0.0201565f, -0.0228687f, -0.0109774f, 0.00556081f, -0.00296738f, -0.0163416f, 0.00970657f, 0.0121291f, -0.0251342f, 0.0079022f, -0.00130572f, 0.0971794f, -0.00335875f, 0.00908426f, 0.056242f, 0.000834502f, -0.0429498f, 0.0221595f, 0.0654803f, 0.016904 };
	float B[81] = { 1.10726f, -0.559241f, -0.0401457f, 0.779982f, -0.327908f, 0.0141622f, -0.0655929f, -0.00605681f, -0.0526496f, -0.158437f, 0.00284327f, -0.113706f, -0.019301f, 0.15953f, 0.0309637f, -0.276185f, 0.00387576f, -0.00555977f, -0.106035f, 0.00829119f, -0.0339351f, -0.00776188f, -0.0158417f, 0.00825391f, -0.0625008f, -0.0301108f, -0.00148979f, 0.0151475f, -0.00588707f, 0.00144811f, -0.117723f, 0.0619562f, 0.00265061f, -0.11142f, 0.00210644f, 0.123467f, -0.0123589f, 0.0140501f, 0.0110725f, -0.00849858f, 0.00244476f, 0.00304824f, 0.0717219f, -0.0925875f, -0.00163217f, 0.0108672f, -0.0147742f, -0.0648016f, 0.0203032f, 0.0222668f, 0.0089237f, -0.00926039f, -0.00540128f, 0.0105335f, -0.0010701f, 0.000903082f, 0.0734163f, 0.0968099f, 0.00794082f, -0.0541871f, -0.00316426f, 0.0750144f, -0.00605994f, -0.0853287f, 0.0102864f, -0.0010008f, -0.00696846f, -0.000243571f, 0.00772774f, -0.0112401f, 0.00699958f, -0.00560367f, -0.0646164f, 0.0150468f, 0.002712f, 0.0423412f, -0.00316962f, -0.0169736f, 0.0175641f, 0.0480972f, -0.0215722 };
	float A[81] = { 3.54153f, -0.00332052f, 0.00142536f, 0.00676359f, 0.0310132f, -0.00546847f, 0.0115701f, 0.000670212f, -0.0148754f, 0.0110475f, 0.00520225f, 0.00528286f, 0.0108673f, -0.0190633f, 0.00426404f, -0.00766548f, -0.00480496f, 0.00388207f, 0.0151012f, -0.000941544f, 0.00163407f, -0.0129595f, 0.00589653f, 0.0115786f, -0.00855349f, 0.0137731f, 0.00458845f, -0.0104254f, -0.0157506f, 0.0123256f, 0.00312044f, -0.002699f, 0.00229152f, -0.00702167f, 0.00136206f, 0.0192831f, -0.00245452f, 0.0154886f, 0.019783f, -0.0125717f, 0.00549089f, 0.00071109f, 0.0137543f, -0.00857661f, -0.00357028f, -0.00350105f, 0.0072972f, -0.0109764f, -0.0238948f, -0.0105825f, -0.00250056f, 0.0150351f, 0.00275682f, -0.0137828f, 0.018523f, 0.00386341f, 0.007168f, 0.014878f, 0.0265702f, -0.0144901f, -0.000547991f, -0.010869f, -0.00519191f, -0.0193904f, 0.0118262f, 0.0258426f, -0.0175617f, -0.000997433f, 0.0196882f, -0.0217456f, 0.0146962f, 0.00626912f, -0.000343306f, -0.00176377f, -0.0016489f, 0.0096597f, 0.00264998f, -0.0249466f, 0.0149357f, 0.0190471f, 0.0226404 };
	for (int i = 0; i < 81; ++i)
	{
		shVector.at(i) = NColor4f(R[i], G[i], B[i], A[i]);
	}

	wm.Multiply(t, shVector, rotatedShvector);
	std::cout << std::fixed <<std::setprecision(4);
	OutputWignerMatrixByIndex();
}

int main()
{
	UnitTest_WignerMatrixConstruction();
	system("pause");
	return 0;
}