
/***********************************************************************

								h£ºSweepingTrail

	A Sweeping trail several main characteristic:
	1. a trail path is driven by a sequence of spatial line segments
	2. adjacent line segments pairs can build up 2 triangles ( or a spatial 'quad')
	3. the header of the trail (the head line segment) must be updated in every frame
	4. the header of the trail should be "cooled down" when reached a given time duration limit.
			A new "free" header line trail shall be generated by then.
	5. the tail of the trail(the last line segment) must be updated in every frame, and
			approaching to the second last line segment over time to reduce the area 
			of the last quad (Meanwhile, the u coord of the tail vertices is maintained to 1)
	6. (2018.7.23)the headers' vertices u coord should be 0, while the tail should be 1.


	vector of line segment (vector index 0-->n, line/vertex index 0-->n)
	v_0	-----	 v_2	......	-----		v_n-3	------	v_n-1
	  |											  |						  |
	v_1 -----	v_3  ......	-----		v_n-2	------	v_n-0(free tail)(approaching the 2nd last LS)
	(free header)							

	sweeping trail moving direction
	<---------------------

************************************************************************/

#include "Noise3D.h"

using namespace Noise3D;

Noise3D::ISweepingTrail::ISweepingTrail() :
	mHeaderCoolDownTimer(0.0f),
	mHeaderCoolDownTimeThreshold(20.0f),
	mMaxLifeTimeOfLS(1000.0f)
{
}

Noise3D::ISweepingTrail::~ISweepingTrail()
{
	ReleaseCOM(m_pVB_Gpu);
}

void Noise3D::ISweepingTrail::SetHeaderLineSegment(N_LineSegment lineSeg)
{
	mFreeHeader = lineSeg;
	//if (!mIsHeaderActive)mIsHeaderActive = true;
}

void Noise3D::ISweepingTrail::SetHeaderCoolDownTimeThreshold(float duration)
{
	mHeaderCoolDownTimeThreshold = duration;
}

void Noise3D::ISweepingTrail::SetMaxLifeTimeOfLineSegment(float duration)
{
	mMaxLifeTimeOfLS = duration;
}

uint32_t Noise3D::ISweepingTrail::GetActiveVerticesCount()
{
	return mVB_Mem.size();
}

/*void Noise3D::ISweepingTrail::SetHeaderCoolDownDistance(float distance)
{
	mHeaderCoolDownDistanceThreshold = distance;
}*/

void Noise3D::ISweepingTrail::Update(float deltaTime)
{
	//timer add
	mHeaderCoolDownTimer += deltaTime;

	//ensure that there is at least one cooled down line segment
	if (mFixedLineSegments.empty())
	{
		mFixedLineSegments.push_back(mFreeHeader);
		//maybe it's in initial state, reset the tail
		mFreeTail_Start = mFreeHeader;
		mFreeTail_Current = mFreeHeader;
	}

	mFunction_CoolDownHeader();
	mFunction_MoveAndCollapseTail();
	mFunction_UpdateVertexBufferInMem();
	mFunction_UpdateToGpuBuffer();
}

bool Noise3D::ISweepingTrail::IsRenderable()
{
	return mVB_Mem.size()>=6;//at least a quad(emmm, ideally it should have at least 2 quads)
}

/*****************************************************************
											PRIVATE
*****************************************************************/
bool NOISE_MACRO_FUNCTION_EXTERN_CALL Noise3D::ISweepingTrail::mFunction_InitGpuBuffer(UINT maxVertexCount)
{
	D3D11_SUBRESOURCE_DATA tmpInitData_Vertex;
	ZeroMemory(&tmpInitData_Vertex, sizeof(tmpInitData_Vertex));
	mVB_Mem.resize(maxVertexCount);
	tmpInitData_Vertex.pSysMem = &mVB_Mem.at(0);
	mGpuVertexPoolCapacity = sizeof(N_SweepingTrailVertexType)* maxVertexCount;

	//Simple Vertex!
	D3D11_BUFFER_DESC vbd;
	vbd.ByteWidth = mGpuVertexPoolCapacity;
	vbd.Usage = D3D11_USAGE_DYNAMIC;
	vbd.BindFlags = D3D11_BIND_VERTEX_BUFFER;
	vbd.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
	vbd.MiscFlags = 0;
	vbd.StructureByteStride = 0;

	//create gpu vertex buffer
	int hr = 0;
	hr = D3D::g_pd3dDevice11->CreateBuffer(&vbd, &tmpInitData_Vertex, &m_pVB_Gpu);
	HR_DEBUG(hr, "SweepingTrail : Failed to create vertex pool ! ");

	return true;
}

void Noise3D::ISweepingTrail::mFunction_CoolDownHeader()
{
	//if fixed line segment exist
	if (mFixedLineSegments.size() > 0)
	{
		//cool down current header, and GENERATE a NEW free segment (add to front)
		//note that when a new line segment cool down, we "add front"
		//thus vector.front() is right after the header of the line sequence
		if (mHeaderCoolDownTimer >= mHeaderCoolDownTimeThreshold)
		{
			mFixedLineSegments.insert(mFixedLineSegments.begin(), mFreeHeader);
			mHeaderCoolDownTimer = 0.0f;
		}
	}
}

void Noise3D::ISweepingTrail::mFunction_MoveAndCollapseTail()
{
	//if at least one fixed line segment exists
	if (mFixedLineSegments.size() > 0)
	{

		//the tail keeps moving to the second last line segment. when the last LS reached the second last,
		//the previous last LS can be removed (thus previous last quad has DEGENERATE into a LS)
		//!!!!:An important point: the collapsing time of the last quad == the header cool down threshold
		//!!!because every line segment has their own 'Life Time'. When a line segment is cooled down, its own
		//life timer start from 0 and tick.
		//And now i want ensure that the last LS's texcoord u maintain 1.0f(while it life timer is exactly equals to 'MaxLifeTime'
		//so the last LS must move to adapt, the lerp ratio is computed below
		float tailLSLifeTimer = mFunction_UtComputeLSLifeTimer(mFixedLineSegments.size() + 2 - 1);
		mTailQuadCollapsingRatio = (tailLSLifeTimer - mMaxLifeTimeOfLS) / mHeaderCoolDownTimeThreshold;
		mTailQuadCollapsingRatio = Ut::Clamp(mTailQuadCollapsingRatio, 0.0f, 1.0f);
		mFreeTail_Current.vert1 = Ut::Lerp(mFreeTail_Start.vert1, mFixedLineSegments.back().vert1, mTailQuadCollapsingRatio);
		mFreeTail_Current.vert2 = Ut::Lerp(mFreeTail_Start.vert2, mFixedLineSegments.back().vert2, mTailQuadCollapsingRatio);

		//collapse last quad & degenerate
		if (mTailQuadCollapsingRatio >= 1.0f)
		{
			mFreeTail_Start = mFixedLineSegments.back();
			mFreeTail_Current = mFixedLineSegments.back();
			mFixedLineSegments.pop_back();//pop the last fixed line from the vector's back
		}
	}
}

void Noise3D::ISweepingTrail::mFunction_UpdateVertexBufferInMem()
{
	if (mFixedLineSegments.size() > 0)
	{
		//2 line segment, 2 triangles, 6 vertices
		const int c_quadVertexCount = 6;

		//+2 stands for head and tail
		uint32_t vertexCount = (mFixedLineSegments.size() + 2 - 1) * c_quadVertexCount;
		mVB_Mem.resize(vertexCount);

		//generate quads
		//header quad(header is moving)
		mFunction_UtGenQuad(
			mFreeHeader, mFixedLineSegments.front(),
			mFunction_UtComputeLSLifeTimer(0), mFunction_UtComputeLSLifeTimer(1) ,
			&mVB_Mem.at(c_quadVertexCount *0));

		//middle quads
		for (int i =0; i< mFixedLineSegments.size()-1; ++i)
		{
			mFunction_UtGenQuad(
				mFixedLineSegments.at(i+0), mFixedLineSegments.at(i+1),
				mFunction_UtComputeLSLifeTimer(i+0+1), mFunction_UtComputeLSLifeTimer(i+1+1),//free header is counted in
				&mVB_Mem.at(c_quadVertexCount * (i + 1)));
		}

		//tail quad(tail is moving to collapse)
		mFunction_UtGenQuad(mFixedLineSegments.back(), mFreeTail_Current, 
			mFunction_UtComputeLSLifeTimer(mFixedLineSegments.size()), mMaxLifeTimeOfLS,
			&mVB_Mem.at(vertexCount - 6));

	}
}

void Noise3D::ISweepingTrail::mFunction_UpdateToGpuBuffer()
{
	uint32_t updateByteSize = min(mVB_Mem.size() * sizeof(N_SweepingTrailVertexType) , mGpuVertexPoolCapacity);

	//update to gpu
	//(2018.7.24)if vertex size in memory exceeds GPU vertex pool capacity, then some of the front vertices won't be uploaded.
	D3D11_MAPPED_SUBRESOURCE mappedRes;
	HRESULT hr = D3D::g_pImmediateContext->Map(m_pVB_Gpu, 0, D3D11_MAP_WRITE_DISCARD, NULL, &mappedRes);
	if(FAILED(hr))
	{
		ERROR_MSG("SweepingTrail: Failed to update vertices.");
		return;
	}
	memcpy_s(mappedRes.pData, updateByteSize, &mVB_Mem.at(0), updateByteSize);
	D3D::g_pImmediateContext->Unmap(m_pVB_Gpu, 0);
}

float Noise3D::ISweepingTrail::mFunction_UtDistanceBetweenLine(N_LineSegment & line1, N_LineSegment & line2)
{
	float vertexDist1 = (line1.vert1 - line2.vert1).Length();
	float vertexDist2 = (line1.vert2 - line2.vert2).Length();
	float lineDist = max(vertexDist1, vertexDist2);
	return lineDist;
}

//compute current life time elapsed of line segment in given position
float Noise3D::ISweepingTrail::mFunction_UtComputeLSLifeTimer(int index)
{
	//index==0, free header						|
	//index==1, free header+1 fixed LS   |--|
	//index==2, free header+2 fixed LS	|--|-----|
	//index==3, free header+3 fixed LS	|--|-----|-----|
	if (index == 0)return 0.0f;
	return (mHeaderCoolDownTimer + (index-1) * mHeaderCoolDownTimeThreshold);
}

//gen quad to given mem position (6 vertices occupied)
void Noise3D::ISweepingTrail::mFunction_UtGenQuad(N_LineSegment & front, N_LineSegment & back, float frontLifeTimer, float backLifeTimer, N_SimpleVertex* quad)
{
	/*
	vector of line segment (vector index 0-->n, line/vertex index n-->0)
	v_n	-----		......	-----		v_3	------	v_1		(v=1.0f)
	  |										  |					  |
	v_n-1 -----	......	-----		v_2	------	v_0		(v=0.0f)

	sweeping trail moving direction
	--------------------->*/

	//Position
	//021
	quad[0].Pos = front.vert1;
	quad[1].Pos = back.vert1;
	quad[2].Pos = front.vert2;

	//123
	quad[3].Pos = front.vert2;
	quad[4].Pos = back.vert1;
	quad[5].Pos = back.vert2;

	//UV, all texcoord.u decreases in a constant rate (then clamp [0,1])
	//ensure that the tail line segment' texcoord.u is 0 (if the front's texcoord.u >1, clamp)
	quad[0].TexCoord = NVECTOR2(frontLifeTimer	/ mMaxLifeTimeOfLS , 0.0f);
	quad[1].TexCoord = NVECTOR2(backLifeTimer / mMaxLifeTimeOfLS, 0.0f);
	quad[2].TexCoord = NVECTOR2(frontLifeTimer / mMaxLifeTimeOfLS, 1.0f);

	quad[3].TexCoord = NVECTOR2(frontLifeTimer / mMaxLifeTimeOfLS, 1.0f);
	quad[4].TexCoord = NVECTOR2(backLifeTimer / mMaxLifeTimeOfLS, 0.0f);
	quad[5].TexCoord = NVECTOR2(backLifeTimer / mMaxLifeTimeOfLS, 1.0f);

	quad[0].Color = NVECTOR4(quad[0].TexCoord.x, quad[0].TexCoord.y,0.0f, 1.0f);
	quad[1].Color = NVECTOR4(quad[1].TexCoord.x, quad[1].TexCoord.y, 0.0f, 1.0f);
	quad[2].Color = NVECTOR4(quad[2].TexCoord.x, quad[2].TexCoord.y, 0.0f, 1.0f);

	quad[3].Color = NVECTOR4(quad[3].TexCoord.x, quad[3].TexCoord.y, 0.0f, 1.0f);
	quad[4].Color = NVECTOR4(quad[4].TexCoord.x, quad[4].TexCoord.y, 0.0f, 1.0f);
	quad[5].Color = NVECTOR4(quad[5].TexCoord.x, quad[5].TexCoord.y, 0.0f, 1.0f);
}
