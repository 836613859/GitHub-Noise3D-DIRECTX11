
/***********************************************************************

								h£ºSweepingTrail

	A Sweeping trail several main characteristic:
	1. a trail path is driven by a sequence of spatial line segments
	2. adjacent line segments pairs can build up 2 triangles ( or a spatial 'quad')
	3. the header of the trail (the head line segment) must be updated in every frame
	4. the header of the trail should be "cooled down" when reached a given time duration limit.
			A new "free" header line trail shall be generated by then.
	5. the tail of the trail(the last line segment) must be updated in every frame, and
			approaching to the second last line segment over time to reduce the area 
			of the last quad (Meanwhile, the u coord of the tail vertices is maintained to 1)
	6. (2018.7.23)the headers' vertices u coord should be 0, while the tail should be 1.


	vector of line segment (vector index 0-->n, line/vertex index n-->0)
	v_n	-----		......	-----		v_3	------	v_1
	  |										  |					  |
	v_n-1 -----	......	-----		v_2	------	v_0

	sweeping trail moving direction
	--------------------->

************************************************************************/

#include "Noise3D.h"

using namespace Noise3D;

Noise3D::ISweepingTrail::ISweepingTrail() :
	//mIsHeaderActive(false),
	//mIsTailActive(false),
	//mHeaderCoolDownDistanceThreshold(1.0f),
	mHeaderCoolDownTimer(0.0f),
	mTailQuadCollapsingTimer(0.0f),
	mHeaderCoolDownTimeThreshold(20.0f),
	mTailQuadCollapseDuration(20.0f)
{
}

Noise3D::ISweepingTrail::~ISweepingTrail()
{
	ReleaseCOM(m_pVB_Gpu);
}

void Noise3D::ISweepingTrail::SetHeaderLineSegment(N_LineSegment lineSeg)
{
	mFreeHeader = lineSeg;
	//if (!mIsHeaderActive)mIsHeaderActive = true;
}

void Noise3D::ISweepingTrail::SetHeaderCoolDownTimeThreshold(float duration)
{
	mHeaderCoolDownTimeThreshold = duration;
}

/*void Noise3D::ISweepingTrail::SetHeaderCoolDownDistance(float distance)
{
	mHeaderCoolDownDistanceThreshold = distance;
}*/

void Noise3D::ISweepingTrail::SetTailCollapsedTime(float duration)
{
	mTailQuadCollapseDuration = duration;
}

void Noise3D::ISweepingTrail::Update(float deltaTime)
{
	//timer add
	mHeaderCoolDownTimer += deltaTime;
	mTailQuadCollapsingTimer += deltaTime;

	//ensure that there is at least one cooled down line segment
	if (mFixedLineSegments.empty())
	{
		mFixedLineSegments.push_back(mFreeHeader);
		//maybe it's in initial state, reset the tail
		mFreeTail_Start = mFreeHeader;
		mFreeTail_Current = mFreeHeader;
	}

	mFunction_CoolDownHeader();
	mFunction_MoveAndCollapseTail();
	mFunction_UpdateVertexBufferInMem();
	mFunction_UpdateToGpuBuffer();
}

bool Noise3D::ISweepingTrail::IsRenderable()
{
	return mFixedLineSegments.size()>0;
}

/*****************************************************************
											PRIVATE
*****************************************************************/
bool NOISE_MACRO_FUNCTION_EXTERN_CALL Noise3D::ISweepingTrail::mFunction_InitGpuBuffer(UINT maxVertexCount)
{
	D3D11_SUBRESOURCE_DATA tmpInitData_Vertex;
	ZeroMemory(&tmpInitData_Vertex, sizeof(tmpInitData_Vertex));
	tmpInitData_Vertex.pSysMem = &mVB_Mem.at(0);
	mVB_Mem.resize(maxVertexCount);
	mGpuVertexPoolCapacity = sizeof(N_SweepingTrailVertexType)* maxVertexCount;

	//Simple Vertex!
	D3D11_BUFFER_DESC vbd;
	vbd.ByteWidth = mGpuVertexPoolCapacity;
	vbd.Usage = D3D11_USAGE_DYNAMIC;
	vbd.BindFlags = D3D11_BIND_VERTEX_BUFFER;
	vbd.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
	vbd.MiscFlags = 0;
	vbd.StructureByteStride = 0;

	//create gpu vertex buffer
	int hr = 0;
	hr = D3D::g_pd3dDevice11->CreateBuffer(&vbd, &tmpInitData_Vertex, &m_pVB_Gpu);
	HR_DEBUG(hr, "SweepingTrail : Failed to create vertex pool ! ");
}

void Noise3D::ISweepingTrail::mFunction_CoolDownHeader()
{
	//if fixed line segment exist
	if (mFixedLineSegments.size() > 0)
	{
		//cool down current header, and GENERATE a NEW free segment (push to back)
		//note that when a new line segment cool down, we use "push back"
		//thus vector.back() is right after the header of the line sequence
		if (mHeaderCoolDownTimer >= mHeaderCoolDownTimeThreshold)
		{
			mFixedLineSegments.push_back(mFreeHeader);
		}
	}
}

void Noise3D::ISweepingTrail::mFunction_MoveAndCollapseTail()
{
	//if at least one fixed line segment exists
	if (mFixedLineSegments.size() > 0)
	{
		//1.collapse last quad & degenerate
		//OR
		//2.move the last line segment
		if (mTailQuadCollapsingTimer >= mTailQuadCollapseDuration)
		{
			mFreeTail_Start = mFixedLineSegments.front();
			mFreeTail_Current = mFixedLineSegments.front();
			mFixedLineSegments.erase(mFixedLineSegments.begin());//pop the last fixed line from the vector's front
		}
		else
		{
			//the tail keeps moving to the second last line segment. when the last LS reached the second last,
			//the previous last LS can be removed (thus previous last quad has DEGENERATE into a LS)
			float tailLerpRatio = mTailQuadCollapsingTimer / mTailQuadCollapseDuration;
			mFreeTail_Current.vert1 = Ut::Lerp(mFreeTail_Start.vert1, mFixedLineSegments.front().vert1, tailLerpRatio);
			mFreeTail_Current.vert2 = Ut::Lerp(mFreeTail_Start.vert2, mFixedLineSegments.front().vert2, tailLerpRatio);
		}
	}
}

void Noise3D::ISweepingTrail::mFunction_UpdateVertexBufferInMem()
{
	if (mFixedLineSegments.size() > 0)
	{
		//2 line segment, 2triangles, 6 vertices
		const int c_quadVertexCount = 6;

		//+2 stands for head and tail
		uint32_t vertexCount = (mFixedLineSegments.size() + 2 - 1) * c_quadVertexCount;
		mVB_Mem.resize(vertexCount);

		//generate quad
		mFunction_Util_GenQuad(mFreeHeader, mFixedLineSegments.front(), &mVB_Mem.at(c_quadVertexCount *0));
		for (int i = 0; i < mFixedLineSegments.size() - 1; ++i)
		{
			mFunction_Util_GenQuad(mFixedLineSegments.at(i), mFixedLineSegments.at(i + 1), &mVB_Mem.at(c_quadVertexCount * (i + 1)));
		}
		mFunction_Util_GenQuad(mFixedLineSegments.back(), mFreeTail_Current, &mVB_Mem.at(vertexCount - 6));

	}
}

void Noise3D::ISweepingTrail::mFunction_UpdateToGpuBuffer()
{
	uint32_t updateByteSize = min(mVB_Mem.size() * sizeof(N_SweepingTrailVertexType) , mGpuVertexPoolCapacity);

	//update to gpu
	//(2018.7.24)if vertex size in memory exceeds GPU vertex pool capacity, then some of the front vertices won't be uploaded.
	D3D11_MAPPED_SUBRESOURCE mappedRes;
	D3D::g_pImmediateContext->Map(m_pVB_Gpu, 0, D3D11_MAP_WRITE, NULL, &mappedRes);
	memcpy_s(mappedRes.pData, updateByteSize, &mVB_Mem.at(0), updateByteSize);
	D3D::g_pImmediateContext->Unmap(m_pVB_Gpu, 0);
}

float Noise3D::ISweepingTrail::mFunction_Util_DistanceBetweenLine(N_LineSegment & line1, N_LineSegment & line2)
{
	float vertexDist1 = (line1.vert1 - line2.vert1).Length();
	float vertexDist2 = (line1.vert2 - line2.vert2).Length();
	float lineDist = max(vertexDist1, vertexDist2);
	return lineDist;
}

//gen quad to given mem position (6 vertices occupied)
void Noise3D::ISweepingTrail::mFunction_Util_GenQuad(N_LineSegment & front, N_LineSegment & back, N_SimpleVertex* quad)
{
	/*
	vector of line segment (vector index 0-->n, line/vertex index n-->0)
	v_n	-----		......	-----		v_3	------	v_1
	  |										  |					  |
	v_n-1 -----	......	-----		v_2	------	v_0

	sweeping trail moving direction
	--------------------->*/

	//Position
	//021
	quad[0].Pos = front.vert1;
	quad[1].Pos = back.vert1;
	quad[2].Pos = front.vert2;
	//123
	quad[3].Pos = front.vert2;
	quad[4].Pos = back.vert1;
	quad[5].Pos = back.vert2;

	//UV, all texcoord.u decreases in a constant rate (then clamp [0,1])
	//ensure that the tail line segment' texcoord.u is 0 (if the front's texcoord.u >1, clamp)

}
