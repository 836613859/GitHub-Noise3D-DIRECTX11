
/***********************************************************************

								h£ºSweepingTrail

	A Sweeping trail several main characteristic:
	1. a trail path is driven by a sequence of spatial line segments
	2. adjacent line segments pairs can build up 2 triangles ( or a spatial 'quad')
	3. the header of the trail (the head line segment) must be updated in every frame
	4. the header of the trail should be "cooled down" when reached a given time duration limit.
			A new "free" header line trail shall be generated by then.
	5. the tail of the trail(the last line segment) must be updated in every frame, and
			approaching to the second last line segment over time to reduce the area 
			of the last quad (Meanwhile, the u coord of the tail vertices is maintained to 1)
	6. (2018.7.23)the headers' vertices u coord should be 0, while the tail should be 1.


	vector of line segment (vector index 0-->n, line/vertex index 0-->n)
	v_0	-----	 v_2	......	-----		v_n-3	------	v_n-1
	  |											  |						  |
	v_1 -----	v_3  ......	-----		v_n-2	------	v_n-0(free tail)(approaching the 2nd last LS)
	(free header)							

	sweeping trail moving direction
	<---------------------

************************************************************************/

#include "Noise3D.h"
#include "SweepingTrail.h"

using namespace Noise3D;

Noise3D::SweepingTrail::SweepingTrail() :
	mInterpolationStepCount(1),
	mFreeHeaderInterpStepCount(1),
	mGeneratedVerticesCount(0),
	mCubicHermiteTangentScale(0.5f),
	mGpuVertexPoolByteCapacity(0),
	mGpuPoolMaxVertexCount(0),
	mHeaderCoolDownTimer(0.0f),
	mHeaderCoolDownTimeThreshold(20.0f),
	mMaxLifeTimeOfLS(1000.0f),
	mFreeTailTangent1(0,0,0),
	mFreeTailTangent2(0, 0, 0)
{
}

Noise3D::SweepingTrail::~SweepingTrail()
{
	ReleaseCOM(m_pVB_Gpu);
}

void Noise3D::SweepingTrail::SetHeader(N_LineSegment lineSeg)
{
	//set header in local space. transformation will be applied in 'mFunc_CoolDownFreeHeader'
	mFreeHeader = lineSeg;
}

N_LineSegment Noise3D::SweepingTrail::GetHeader()
{
	return mFreeHeader;
}

Vec3 Noise3D::SweepingTrail::GetHeaderCenterPos()
{
	return (mFreeHeader.vert1+mFreeHeader.vert2)/2.0f;
}

void Noise3D::SweepingTrail::SetHeaderCoolDownTimeThreshold(float duration)
{
	mHeaderCoolDownTimeThreshold = duration;
}

void Noise3D::SweepingTrail::SetMaxLifeTimeOfLineSegment(float duration)
{
	mMaxLifeTimeOfLS = duration;
}

uint32_t Noise3D::SweepingTrail::GetActiveVerticesCount()
{
	//return Ut::Clamp( (mFixedLineSegments.size()+1) * mInterpolationStepCount * 6,0, mGpuPoolMaxVertexCount);
	return mGeneratedVerticesCount;
}

void Noise3D::SweepingTrail::SetInterpolationStepCount(uint32_t count)
{
	if (count == 0)count = 1;
	mInterpolationStepCount = count;
}

void Noise3D::SweepingTrail::SetFreeHeaderInterpolationStepCount(uint32_t count)
{
	mFreeHeaderInterpStepCount = count;
}

void Noise3D::SweepingTrail::SetCubicHermiteTangentScale(float length)
{
	mCubicHermiteTangentScale = length;
}

void Noise3D::SweepingTrail::Update(float deltaTime)
{
	//timer add
	mHeaderCoolDownTimer += deltaTime;

	//ensure that there is at least one cooled down line segment
	if (mFixedLineSegments.empty())
	{
		mFixedLineSegments.push_back(mFreeHeader);
		//maybe it's in initial state, reset the tail
		mFreeTail_Start = mFreeHeader;
		//mFreeHeader_PreviousState = mFreeHeader;
		mFreeTailTangent1 = Vec3(0, 0, 0);
		mFreeTailTangent2 = Vec3(0, 0, 0);
	}

	mFunction_CoolDownHeader();
	mFunction_MoveAndCollapseTail();
	mFunction_EstimateTangents();
	mFunction_GenVerticesAndUpdateToGpuBuffer();
}

void Noise3D::SweepingTrail::SetTextureName(N_UID texName)
{
	mTextureUid = texName;
}

N_UID Noise3D::SweepingTrail::GetTextureName()
{
	return mTextureUid;
}

void Noise3D::SweepingTrail::GetTangentList(std::vector<std::pair<Vec3, Vec3>>& outList)
{
	//copy the tangent list outside for debug use
	outList = mTangentList;
}

void Noise3D::SweepingTrail::GetVerticesList(std::vector<Noise3D::N_LineSegment>& outList)
{
	outList = mFixedLineSegments;
	outList.insert(outList.begin(), mFreeHeader);
	outList.push_back(mFreeTail_Start);
}

N_AABB Noise3D::SweepingTrail::GetLocalAABB()
{
	//sweeping trail's vertices are dynamically generated, not easy to compute AABB
	return N_AABB();
}

N_AABB Noise3D::SweepingTrail::ComputeWorldAABB_Accurate()
{
	return N_AABB();
}

N_AABB Noise3D::SweepingTrail::ComputeWorldAABB_Fast()
{
	return N_AABB();
}

N_BoundingSphere Noise3D::SweepingTrail::ComputeWorldBoundingSphere_Accurate()
{
	return N_BoundingSphere();
}

NOISE_SCENE_OBJECT_TYPE Noise3D::SweepingTrail::GetObjectType()const
{
	return NOISE_SCENE_OBJECT_TYPE::SWEEPING_TRAIL;
}

/*****************************************************************
											PRIVATE
*****************************************************************/
bool NOISE_MACRO_FUNCTION_EXTERN_CALL Noise3D::SweepingTrail::mFunction_InitGpuBuffer(UINT maxVertexCount)
{
	D3D11_SUBRESOURCE_DATA tmpInitData_Vertex;
	ZeroMemory(&tmpInitData_Vertex, sizeof(tmpInitData_Vertex));
	std::vector<N_SweepingTrailVertexType> tmpVec(maxVertexCount);
	tmpInitData_Vertex.pSysMem = &tmpVec.at(0);
	mGpuVertexPoolByteCapacity = sizeof(N_SweepingTrailVertexType)* maxVertexCount;
	mGpuPoolMaxVertexCount = maxVertexCount;

	//Simple Vertex!
	D3D11_BUFFER_DESC vbd;
	vbd.ByteWidth = mGpuVertexPoolByteCapacity;
	vbd.Usage = D3D11_USAGE_DYNAMIC;
	vbd.BindFlags = D3D11_BIND_VERTEX_BUFFER;
	vbd.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
	vbd.MiscFlags = 0;
	vbd.StructureByteStride = 0;

	//create gpu vertex buffer
	int hr = 0;
	hr = D3D::g_pd3dDevice11->CreateBuffer(&vbd, &tmpInitData_Vertex, &m_pVB_Gpu);
	HR_DEBUG(hr, "SweepingTrail : Failed to create vertex pool !");

	return true;
}

void Noise3D::SweepingTrail::mFunction_CoolDownHeader()
{
	//if fixed line segment exist
	if (mFixedLineSegments.size() > 0)
	{
		//cool down current header, and GENERATE a NEW free segment (add to front)
		//note that when a new line segment cool down, we "add front"
		//thus vector.front() is right after the header of the line sequence
		if (mHeaderCoolDownTimer >= mHeaderCoolDownTimeThreshold)
		{
			//transform to world space first (doesn't consider scale)
			N_LineSegment lineSegW;
			Matrix mat = ISceneObject::GetAttachedSceneNode()->EvalWorldTransform().GetRigidTransformMatrix();
			lineSegW.vert1 = AffineTransform::TransformVector_MatrixMul(mFreeHeader.vert1, mat);
			lineSegW.vert2 = AffineTransform::TransformVector_MatrixMul(mFreeHeader.vert2, mat);

			mFixedLineSegments.insert(mFixedLineSegments.begin(), lineSegW);
			mHeaderCoolDownTimer = 0.0f;
		}
	}
}

void Noise3D::SweepingTrail::mFunction_MoveAndCollapseTail()
{
	//if at least one fixed line segment exists
	if (mFixedLineSegments.size() > 0)
	{

		//the tail keeps moving to the second last line segment. when the last LS reached the second last,
		//the previous last LS can be removed (thus previous last quad has DEGENERATE into a LS)
		//!!!!:An important point: the collapsing time of the last quad == the header cool down threshold
		//!!!because every line segment has their own 'Life Time'. When a line segment is cooled down, its own
		//life timer start from 0 and tick.
		//And now i want ensure that the last LS's texcoord u maintain 1.0f(while it life timer is exactly equals to 'MaxLifeTime'
		//so the last LS must move to adapt, the lerp ratio is computed below
		float tailLSLifeTimer = mFunction_UtComputeLifeTimer(mFixedLineSegments.size() + 2 - 1);
		mTailQuadCollapsingRatio = (tailLSLifeTimer - mMaxLifeTimeOfLS) / mHeaderCoolDownTimeThreshold;
		mTailQuadCollapsingRatio = Ut::Clamp(mTailQuadCollapsingRatio, 0.0f, 1.0f);

		//collapse last quad & degenerate
		if (mTailQuadCollapsingRatio >= 1.0f)
		{
			mFreeTail_Start = mFixedLineSegments.back();

			//store the 2nd last tangents to new free tail tangent
			mFreeTailTangent1 = mTangentList.at(mTangentList.size() - 2).first;
			mFreeTailTangent2 = mTangentList.at(mTangentList.size() - 2).second;
			mFixedLineSegments.pop_back();//pop the last fixed line from the vector's back
			mTailQuadCollapsingRatio = 0.0f;
		}
	}
}

void Noise3D::SweepingTrail::mFunction_EstimateTangents()
{
	//angle bisector
	mTangentList.resize(mFixedLineSegments.size() + 2);
	/*mTangentList.at(0).first = mFreeHeader_PreviousState.vert1 - mFreeHeader.vert1;
	mTangentList.at(0).first *= mCubicHermiteTangentScale;
	mTangentList.at(0).second = mFreeHeader_PreviousState.vert2 - mFreeHeader.vert2;
	mTangentList.at(0).second *= mCubicHermiteTangentScale;
	*/
	mTangentList.at(0).first = mFixedLineSegments.front().vert1 - mFreeHeader.vert1;
	mTangentList.at(0).first *= mCubicHermiteTangentScale;
	mTangentList.at(0).second = mFixedLineSegments.front().vert2 - mFreeHeader.vert2;
	mTangentList.at(0).second *= mCubicHermiteTangentScale;

	for (int i = 1; i <= int(mFixedLineSegments.size()); ++i)
	{
		N_LineSegment frontLS = mFunction_UtGetLineSegment(i - 1);
		N_LineSegment backLS = mFunction_UtGetLineSegment(i + 1);
		mTangentList.at(i).first = backLS.vert1 - frontLS.vert1;
		mTangentList.at(i).first *= mCubicHermiteTangentScale;
		mTangentList.at(i).second = backLS.vert2 - frontLS.vert2;
		mTangentList.at(i).second *= mCubicHermiteTangentScale;
	}

	mTangentList.at(mFixedLineSegments.size() + 1).first = mFreeTailTangent1;
	mTangentList.at(mFixedLineSegments.size() + 1).second = mFreeTailTangent2;
}

void Noise3D::SweepingTrail::mFunction_GenVerticesAndUpdateToGpuBuffer()
{

	if (mFixedLineSegments.size() > 0)
	{
		//**********Map*********
		//(2018.7.24)if vertex size in memory exceeds GPU vertex pool capacity, then some of the front vertices won't be uploaded.
		//pre-caution for index-out-of-range situation
		D3D11_MAPPED_SUBRESOURCE mappedRes;
		HRESULT hr = D3D::g_pImmediateContext->Map(m_pVB_Gpu, 0, D3D11_MAP_WRITE_DISCARD, NULL, &mappedRes);
		if (FAILED(hr))
		{
			ERROR_MSG("SweepingTrail: Failed to update vertices.");
			return;
		}

		int maxStartVertexIndex = mGpuPoolMaxVertexCount - mInterpolationStepCount * 6;
		int vertexIndexOffset = 0;
		int totalRegionCount = mFixedLineSegments.size() + 1;
		for (int i = 0; i < totalRegionCount; ++i)//be careful of corner cases
		{
			if (vertexIndexOffset > maxStartVertexIndex)
			{
				return;//not enought mem space, exit
			}
			N_SweepingTrailVertexType* tmpMemAddr = (N_SweepingTrailVertexType*)mappedRes.pData + vertexIndexOffset;
			N_GenQuadInfo tmpInfo;
			N_LineSegment frontLS = mFunction_UtGetLineSegment(i);
			N_LineSegment backLS = mFunction_UtGetLineSegment(i + 1);
			tmpInfo.interpolation_steps = mInterpolationStepCount;
			tmpInfo.frontPos1 = frontLS.vert1;
			tmpInfo.frontPos2 = frontLS.vert2;
			tmpInfo.backPos1 = backLS.vert1;
			tmpInfo.backPos2 = backLS.vert2;
			//uses adjacent vertices to estimate current vertex's tangent, CORNER CASES are dealt with inside the function
			tmpInfo.frontTangent1 = mTangentList.at(i).first;
			tmpInfo.frontTangent2 = mTangentList.at(i).second;
			tmpInfo.backTangent1 = mTangentList.at(i+1).first;
			tmpInfo.backTangent2 = mTangentList.at(i+1).second;

			//interpolation of the last region is dealt with differently (to ensure that the tail collapses on history path)
			if (i == totalRegionCount - 1)
			{
				tmpInfo.collapsingFactor = mTailQuadCollapsingRatio;
			}

			//interpolation steps for free header quad (better be small, to prevent 'snake walking'(ÉßÆ¤×ßÎ»23333))
			if (i == 0)
			{
				tmpInfo.interpolation_steps = mFreeHeaderInterpStepCount;
			}

			//Gen normal interpolated Quads
			vertexIndexOffset += mFunction_UtGenQuad(tmpInfo, mFunction_UtComputeLifeTimer(i), mFunction_UtComputeLifeTimer(i + 1), tmpMemAddr);

			//**********Unmap***************
			D3D::g_pImmediateContext->Unmap(m_pVB_Gpu, 0);
			mGeneratedVerticesCount = vertexIndexOffset;
		}
	}

}

//compute current life time elapsed of line segment in given position
float Noise3D::SweepingTrail::mFunction_UtComputeLifeTimer(int index)
{
	//index==0, free header						|
	//index==1, free header+1 fixed LS   |--|
	//index==2, free header+2 fixed LS	|--|-----|
	//index==3, free header+3 fixed LS	|--|-----|-----|
	if (index == 0)return 0.0f;
	return (mHeaderCoolDownTimer + (index-1) * mHeaderCoolDownTimeThreshold);
}

//gen quad vertices to given memory position
int Noise3D::SweepingTrail::mFunction_UtGenQuad(const N_GenQuadInfo& desc, float frontLifeTimer, float backLifeTimer, N_SweepingTrailVertexType* quad)
{
	//skip de-generated quad(or Cubic Hermite interp will cause some weird triangles to intrude)
	if (desc.frontPos1 == desc.backPos1 && desc.frontPos2 == desc.backPos2)
	{
		return 0;
	}

	/*
	vector of line segment (vector index 0-->n, line/vertex index 0-->n)
	v_0	-----	 v_2	......	-----		v_n-3	------	v_n-1
	  |											  |						  |
	v_1 -----	v_3  ......	-----		v_n-2	------	v_n-0(free tail)(approaching the 2nd last LS)
	(free header)							

	sweeping trail moving direction
	<---------------------
	*/

	//Cubic Hermite interplation is used between each passed-in pair of line segments
	float unitRatio = 1.0f / desc.interpolation_steps;
	for (uint32_t i = 0; i < desc.interpolation_steps; ++i)
	{
		//tailCollapsingFactor is usually 0.0f (but the tail LS's factor will be larger than 0.0f because the tail keep approaching the second last LS)
		float frontLerpRatio = (1.0f - desc.collapsingFactor) *  i * unitRatio;
		float backLerpRatio = (1.0f - desc.collapsingFactor) * (i + 1) * unitRatio;

		//front line segment in interpolaton(start and end line segment is passed in as function param)
		Vec3 interpFrontPos1	=	Ut::CubicHermite(desc.frontPos1, desc.backPos1, desc.frontTangent1 ,desc.backTangent1 , frontLerpRatio);
		Vec3 interpFrontPos2	=	Ut::CubicHermite(desc.frontPos2, desc.backPos2, desc.frontTangent2, desc.backTangent2, frontLerpRatio);
		Vec3 interpBackPos1		=	Ut::CubicHermite(desc.frontPos1, desc.backPos1, desc.frontTangent1, desc.backTangent1, backLerpRatio);
		Vec3 interpBackPos2		=	Ut::CubicHermite(desc.frontPos2, desc.backPos2, desc.frontTangent2, desc.backTangent2, backLerpRatio);
		//Position
		//021
		quad[i * 6 + 0].Pos = interpFrontPos1;
		quad[i * 6 + 1].Pos = interpBackPos1;
		quad[i * 6 + 2].Pos = interpFrontPos2;

		//123
		quad[i * 6 + 3].Pos = interpFrontPos2;
		quad[i * 6 + 4].Pos = interpBackPos1;
		quad[i * 6 + 5].Pos = interpBackPos2;

		//UV, all texcoord.u decreases in a constant rate
		//ensure that the tail line segment' texcoord.u is 0, header is 1
		float frontTexcoordU = Ut::Lerp(frontLifeTimer / mMaxLifeTimeOfLS, backLifeTimer / mMaxLifeTimeOfLS, frontLerpRatio);
		float backTexcoordU = Ut::Lerp(frontLifeTimer / mMaxLifeTimeOfLS, backLifeTimer / mMaxLifeTimeOfLS, backLerpRatio);

		quad[i * 6 + 0].TexCoord = Vec2(frontTexcoordU, 0.0f);
		quad[i * 6 + 1].TexCoord = Vec2(backTexcoordU, 0.0f);
		quad[i * 6 + 2].TexCoord = Vec2(frontTexcoordU, 1.0f);

		quad[i * 6 + 3].TexCoord = Vec2(frontTexcoordU, 1.0f);
		quad[i * 6 + 4].TexCoord = Vec2(backTexcoordU, 0.0f);
		quad[i * 6 + 5].TexCoord = Vec2(backTexcoordU, 1.0f);

		//vertex alpha
		for (int j = 0; j < 6; ++j)
		{
			//texcoord u indicates normalized life timer
			float normalizedLifeTimer = quad[i * 6 + j].TexCoord.x;
			float fadeOutThreshold = 0.9f;
			float alpha = 1.0f;
			if (normalizedLifeTimer < fadeOutThreshold)
			{
				alpha = 1.0f;
			}
			else
			{
				alpha = (1.0f - normalizedLifeTimer) / (1.0f - fadeOutThreshold);
			}
			quad[i * 6 + j].Color = Vec4(0.0f, 0.0f, 0.0f, alpha);
		}

	}

	//vertices generated
	//2 line segment, 2 triangles, 6 vertices
	const int c_quadVertexCount = 6;
	return (desc.interpolation_steps) * c_quadVertexCount;
}

inline N_LineSegment Noise3D::SweepingTrail::mFunction_UtGetLineSegment(int index)
{
	//header
	if (index == 0)return mFreeHeader;
	//tail
	if (index == mFixedLineSegments.size() + 2 - 1)return mFreeTail_Start;
	//middle 
	if (mFixedLineSegments.size() > 0)return mFixedLineSegments.at(index - 1);
	//it shouldn't run to here
	assert(0);
	return mFreeHeader;
}
